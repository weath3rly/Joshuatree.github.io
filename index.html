<!DOCTYPE html>
<html>
<head>
    <title>Joshua Unraveled Lite</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000000; /* Black sky for both day and night */
        }
        #toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px;
            background: #4A3728;
            color: white;
            border: none;
            cursor: pointer;
            font-family: Arial, sans-serif;
            z-index: 2;
        }
        #canvas {
            width: 100%;
            height: 100vh;
        }
    </style>
</head>
<body>
    <button id="toggle">Toggle Day/Night</button>
    <canvas id="canvas"></canvas>
    <!-- Placeholder audio (whispers) -->
    <audio id="english" preload="auto" src="https://cdn.pixabay.com/audio/2022/03/15/09-32-18-637_1.mp3"></audio>
    <audio id="chinese" preload="auto" src="https://cdn.pixabay.com/audio/2023/03/27/04-23-24-867_1.mp3"></audio>

    <!-- Three.js via CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // Scene Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0x000000, 1);

        // Camera Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        camera.position.set(0, 5, 15);
        controls.minDistance = 5;
        controls.maxDistance = 5000;
        controls.update();

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xFF4500, 1);
        directionalLight.position.set(5, 10, 5);
        scene.add(directionalLight);

        // Desert Ground
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshStandardMaterial({
            color: 0x8B5A2B,
            roughness: 0.8,
            metalness: 0.2
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        // Joshua Trees (30 from base code)
        const trees = [];
        const treeCount = 30;
        const treePositions = [];

        for (let i = 0; i < treeCount; i++) {
            let x, z, validPosition = false;
            while (!validPosition) {
                x = (Math.random() - 0.5) * 80;
                z = (Math.random() - 0.5) * 80;
                validPosition = true;
                for (let pos of treePositions) {
                    const distance = Math.sqrt((x - pos.x) ** 2 + (z - pos.z) ** 2);
                    if (distance < 3) {
                        validPosition = false;
                        break;
                    }
                }
            }
            const scale = 0.8 + Math.random() * 0.4;
            treePositions.push({ x, z, scale });
        }

        treePositions.forEach(pos => {
            const treeGroup = new THREE.Group();
            const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1.2, 16);
            const trunkMaterial = new THREE.MeshStandardMaterial({
                color: 0x4A3728,
                emissive: 0x00FFFF,
                emissiveIntensity: 0.2
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            treeGroup.add(trunk);
            const foliageGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const foliageMaterial = new THREE.MeshStandardMaterial({
                color: 0x3D5A1F,
                emissive: 0x00FFFF,
                emissiveIntensity: 0
            });
            const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
            foliage.position.set(0, 1.2, 0);
            treeGroup.add(foliage);
            const vineGeometry = new THREE.BufferGeometry();
            const vinePositions = [];
            for (let i = 0; i < 50; i++) {
                const theta = Math.random() * Math.PI * 2;
                const radius = 0.4 + Math.random() * 0.2;
                const y = 0.2 + Math.random() * 1;
                vinePositions.push(Math.cos(theta) * radius, y, Math.sin(theta) * radius);
            }
            vineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vinePositions, 3));
            const vineMaterial = new THREE.PointsMaterial({
                color: 0x00FFFF,
                size: 0.05,
                transparent: true,
                opacity: 0.8
            });
            const vines = new THREE.Points(vineGeometry, vineMaterial);
            treeGroup.add(vines);

            treeGroup.position.set(pos.x, 0, pos.z);
            treeGroup.scale.set(pos.scale, pos.scale, pos.scale);
            scene.add(treeGroup);
            trees.push({ group: treeGroup, foliageMaterial: foliageMaterial });
        });

        // Shrubs
        const shrubs = [];
        const shrubPositions = [
            { x: -5, z: -5, scale: 1 },
            { x: 7, z: -2, scale: 0.7 },
            { x: -4, z: 2, scale: 0.9 }
        ];

        shrubPositions.forEach(pos => {
            const shrubGroup = new THREE.Group();
            const shrubGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const shrubMaterial = new THREE.MeshStandardMaterial({
                color: 0x3D5A1F,
                emissive: 0x800080,
                emissiveIntensity: 0
            });
            const shrub = new THREE.Mesh(shrubGeometry, shrubMaterial);
            shrubGroup.add(shrub);
            const tendrilGeometry = new THREE.BufferGeometry();
            const tendrilPositions = [];
            for (let i = 0; i < 30; i++) {
                const theta = Math.random() * Math.PI * 2;
                const radius = 0.2 + Math.random() * 0.1;
                const y = 0.1 + Math.random() * 0.2;
                tendrilPositions.push(Math.cos(theta) * radius, y, Math.sin(theta) * radius);
            }
            tendrilGeometry.setAttribute('position', new THREE.Float32BufferAttribute(tendrilPositions, 3));
            const tendrilMaterial = new THREE.PointsMaterial({
                color: 0x800080,
                size: 0.03,
                transparent: true,
                opacity: 0.8
            });
            const tendrils = new THREE.Points(tendrilGeometry, tendrilMaterial);
            shrubGroup.add(tendrils);

            shrubGroup.position.set(pos.x, 0, pos.z);
            shrubGroup.scale.set(pos.scale, pos.scale, pos.scale);
            scene.add(shrubGroup);
            shrubs.push({ group: shrubGroup, material: shrubMaterial });
        });

        // Cacti
        const cacti = [];
        const cactusPositions = [
            { x: -3.5, z: 5, scale: 1 },
            { x: 6.5, z: -1.2, scale: 0.8 },
            { x: -4.5, z: -1.5, scale: 1.1 }
        ];

        cactusPositions.forEach(pos => {
            const cactusGroup = new THREE.Group();
            const trunkGeometry = new THREE.CylinderGeometry(0.15, 0.15, 1, 16);
            const cactusMaterial = new THREE.MeshStandardMaterial({
                color: 0x355E3B,
                emissive: 0x0000FF,
                emissiveIntensity: 0
            });
            const trunk = new THREE.Mesh(trunkGeometry, cactusMaterial);
            cactusGroup.add(trunk);
            const armGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.6, 16);
            const arm = new THREE.Mesh(armGeometry, cactusMaterial);
            arm.position.set(0, 0.8, 0);
            arm.rotation.y = Math.PI / 4;
            cactusGroup.add(arm);
            const tendrilGeometry = new THREE.BufferGeometry();
            const tendrilPositions = [];
            for (let i = 0; i < 30; i++) {
                const theta = Math.random() * Math.PI * 2;
                const radius = 0.2 + Math.random() * 0.1;
                const y = 0.1 + Math.random() * 0.8;
                tendrilPositions.push(Math.cos(theta) * radius, y, Math.sin(theta) * radius);
            }
            tendrilGeometry.setAttribute('position', new THREE.Float32BufferAttribute(tendrilPositions, 3));
            const tendrilMaterial = new THREE.PointsMaterial({
                color: 0x0000FF,
                size: 0.03,
                transparent: true,
                opacity: 0.8
            });
            const tendrils = new THREE.Points(tendrilGeometry, tendrilMaterial);
            cactusGroup.add(tendrils);

            cactusGroup.position.set(pos.x, 0, pos.z);
            cactusGroup.scale.set(pos.scale, pos.scale, pos.scale);
            scene.add(cactusGroup);
            cacti.push({ group: cactusGroup, material: cactusMaterial });
        });

        // Floating Orbs
        const orbs = [];
        const orbCount = 50;
        const orbPositions = [];

        for (let i = 0; i < orbCount; i++) {
            let x, y, z, validPosition = false;
            while (!validPosition) {
                x = (Math.random() - 0.5) * 80;
                y = 1 + Math.random() * 2;
                z = (Math.random() - 0.5) * 80;
                validPosition = true;
                for (let pos of orbPositions) {
                    const distance = Math.sqrt((x - pos.x) ** 2 + (y - pos.y) **
